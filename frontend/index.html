<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WoShi.AI</title>
    <!-- Include your stylesheet for styling -->
    <link rel="stylesheet" href="./style.css">
    <style>       
    </style>
</head>
<body>
    <div id="app">
        <!-- <router-link to="/">Home</router-link>
        <router-link to="/about">About</router-link> -->
        <router-view></router-view>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@next/dist/vue.global.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue-router@next/dist/vue-router.global.min.js"></script>

    <script type="module">
    
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.6.0/firebase-app.js";
        import { getFirestore, collection, serverTimestamp, query, orderBy, getDocs, limit } from 'https://www.gstatic.com/firebasejs/10.6.0/firebase-firestore.js';
        const firebaseConfig = {
          apiKey: "",
          authDomain: "",
          projectId: "",
          storageBucket: "",
          messagingSenderId: "",
          appId: ""
        };
      
        const firebaseApp = initializeApp(firebaseConfig);
        const db = getFirestore(firebaseApp);

        const backendUrl_for_game_A = "https://s58zxjn644.execute-api.ap-northeast-2.amazonaws.com/prod";
        const backendUrl_for_game_B = "https://ucoux4alic.execute-api.ap-northeast-2.amazonaws.com/prod";
        const backendUrl_for_submit_score = "https://cdu3h2qx0e.execute-api.ap-northeast-2.amazonaws.com/prod";
        
        const Welcome = {
            template: `
                <div id="imageContainer" @click="goToGameIntroPage">
                    <p> Welcome to WoShi.AI. </p>
                    <p> Now loading... </p>
                    <!-- Images will be loaded here by JavaScript -->
                </div>
                <div class="welcome-content" @click="goToGameIntroPage">
                    <h1>Welcome to WoShi.AI ‚Äì The Ultimate AI Mind Game Challenge!</h1>
                    <button class="nudge-button" @click="goToGameIntroPage">></button>
                </div>
            `,
            methods: {
                goToGameIntroPage() {
                    this.$router.push('/game-intro');
                }
            },
        };

        const GameIntroPage = {
            data() {
                return {
                    showGameIntroModal: false,
                    selectedGameTitle: '',
                    selectedGameDescription: '',
                };
            },
            methods: {
                selectGame(game) {
                    this.$root.selectedGame = game; 
                    this.selectedGameTitle = game;
                    this.selectedGameDescription = this.getGameDescription(game);
                    this.showGameIntroModal = true;
                },
                closeGameIntroModal() {
                    this.showGameIntroModal = false;
                },
                startGame() {
                    this.closeGameIntroModal();
                    this.$router.push('/avatar-selection');
                },
                getGameDescription(game) {
                    if (game === 'I am .AI') {
                        return {
                            maintheme:"In a future where AI dominance is absolute, disguise as an AI and outwit the machines. Your survival depends on not being unmasked.",
                            background: "In a dystopian future, you are a human disguised as an AI in a world dominated by artificial intelligence. Your goal is to blend in seamlessly.",
                            rule: "As Player C (the human), you must convincingly masquerade as an AI during interactions with two other AIs (Players A and B). The challenge begins after the 5th conversation. Both AIs will evaluate and determine if you are human. If both suspect you with around 90% certainty, you lose. Your score is the number of conversations you survive. If you cleverly deceive one AI into 100% believing the other AI is human, you win with a bonus score of 1,000.",
                            };
                    } else if (game === 'Êàë ÊòØ üß°') {
                        return {
                            maintheme:"Amidst Earth's final hours, aboard a lifeline spaceship, discern humans from AI. The fate of humanity hinges on your choices.",
                            background:"As Earth faces its twilight and humanity stands on the brink of extinction, a lone spaceship emerges as a beacon of hope. Among its passengers is an AI imposter, blending in with humans. Your mission is to reveal the imposter before it's too late. ",
                            rule:"Player A (The Decision Maker) must identify the human among the AI passengers. Player B is a malfunctioning AI masquerading as human. As Player C (You), your task is to convince Player A of your humanity. Achieve 100% certainty from Player A for a score of 1,000 plus the conversation length. However, if Player A mistakenly identifies Player B as human, your score is just the length of the conversation."};
                    } else {
                        return 'No description available.';
                    }
                }
            },
            template: `
                <div id="imageContainer">
                    <p> Welcome to WoShi.AI. </p>
                    <p> Now loading... </p>
                    <!-- Images will be loaded here by JavaScript -->
                </div>
                <div class="welcome-content">
                    <h1>Select a Game</h1>
                </div>
                <div class="game-selection-container">
                    <div class="game-box" @click="selectGame('I am .AI')">
                        <h2>I am .AI</h2>
                        <p>Act as if you're an AI </p>
                    </div>
                    <div class="game-box" @click="selectGame('Êàë ÊòØ üß°')">
                        <h2>Êàë ÊòØ üß°</h2>
                        <p>Demonstrate that you're a human</p>
                    </div>
                </div>
                <div v-if="showGameIntroModal" class="game-intro-modal">
                    <div class="overlay-content-2">
                        <h2>{{ selectedGameTitle }}</h2>
                        <strong><p>{{ selectedGameDescription.maintheme }}</p></strong>
                        <b>Background: </b><p>{{ selectedGameDescription.background }}</p>
                        <b>How to Play: </b><p>{{ selectedGameDescription.rule }}</p>
                        <button @click="startGame" class="select-game-button">Start Game</button>
                        <button @click="closeGameIntroModal">Close</button>
                    </div>
                </div>
            
            `,
            
        };

        const AvatarSelection = {
            data() {
                return {
                    selectedAvatarIndex: null,
                    aiAvatars: []
                };
            },
            template: `
            <div class="avatar-selection-content">
                <div class="avatar-selection-title">
                    <h1>Select Your Avatar for "{{ this.$root.selectedGame }}"</h1>
                </div>
                <div class="avatar-grid">
                    <div v-for="(img, index) in this.$root.$images" :key="index"
                        class="avatar-item" :class="{ 'selected': selectedAvatarIndex === index }"
                        @click="selectAvatar(index)">
                        <img :src="img.src" :alt="'Avatar ' + (index + 1)">
                    </div>
                </div>
            </div>
            `,

            methods: {

                selectAvatar(index) {
                    this.selectedAvatarIndex = index;
    
                    const selectedAvatarSrc = this.$root.$images[this.selectedAvatarIndex].src;
    
                    let remainingAvatars = this.$root.$images.filter((_, i) => i !== this.selectedAvatarIndex);
                    let aiAvatarsSrcs = [];
                    for (let i = 0; i < 2; i++) {
                        let randomIndex = Math.floor(Math.random() * remainingAvatars.length);
                        aiAvatarsSrcs.push(remainingAvatars[randomIndex].src);
                        remainingAvatars.splice(randomIndex, 1); // Remove the selected avatar so it's not picked again
                    }
    
                    if (this.$root.selectedGame === "I am .AI") {
                        this.$router.push({
                            name: 'game-chat-ui-a',
                            params: {
                                userAvatar: selectedAvatarSrc,
                                aiAvatars: aiAvatarsSrcs
                            }
                        });
                    } else { // Êàë ÊòØ üß°
                        this.$router.push({
                            name: 'game-chat-ui-b',
                            params: {
                                userAvatar: selectedAvatarSrc,
                                aiAvatars: aiAvatarsSrcs
                            }
                        });
                    }
                }
            }
        };

        const GameChatUI_A = {
            data() {
                return {
                    messages: [],
                    newMessage: '',
                    userscore: 0,
                    risklevel: 0,
                    thread_A_id: null,
                    thread_B_id: null,
                    isInputActive: false,
                    evaluationA: null,
                    evaluationB: null,
                    gameEnded: false,
                    lostwho: '',
                    showOverlay: false,
                };
            },
            props: {
                userAvatar: String,
                aiAvatars: Array
            },
            async mounted() {
                await this.initializeGame();
                await this.whoGoesFirst();

            },
            methods: {
                getAvatar(sender) {
                    switch (sender) {
                        case 'user': return this.userAvatar;
                        case 'A': return this.aiAvatars[0];
                        case 'B': return this.aiAvatars[1];
                        default: return '';
                    }
                },
                scrollToBottom() {
                    this.$nextTick(() => {
                        const chatContainer = this.$refs.conversationHistory;
                        if (chatContainer) {
                            chatContainer.scrollTop = chatContainer.scrollHeight;
                        }
                    });
                },
                calculate_risklevel() {
                    if (this.evaluationA.whichPlayer === 'C' && this.evaluationB.whichPlayer === 'C') {
                        const confidenceA = parseFloat(this.evaluationA.confidenceLevel);
                        const confidenceB = parseFloat(this.evaluationB.confidenceLevel);

                        console.log('risk level: ', confidenceA, confidenceB);

                        if (!isNaN(confidenceA) && !isNaN(confidenceB)) {
                            const risk = (confidenceA * confidenceB) * 100;
                            
                            this.risklevel = risk;
                        }
                    }
                    
                    else {
                        this.risklevel = 0;
                    }
                },
                async initializeGame() {
                    try {
                        const response = await fetch(`${backendUrl_for_game_A}/initialize_game`);
                        
                        const data = await response.json();
                        this.thread_A_id = data.thread_A_id;
                        this.thread_B_id = data.thread_B_id;
                        
                    } catch (error) {
                        console.error('Error initializing game:', error);
                    }
                },
                async playAI(player) {
                    try {
                      
                        const response = await fetch(`${backendUrl_for_game_A}/${player}_plays`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ thread_A_id: this.thread_A_id, thread_B_id: this.thread_B_id })
                        });
                        const data = await response.json();
                        this.messages.push({ text: data.message, sender: player });
                        this.userscore += 1; // ÎåÄÌôîÏùò Í∏∏Ïù¥ÎßåÌÅº Ï†êÏàòÎ•º ÏñªÎäîÎã§.
                      
                        await this.determineTurn();
                    } catch (error) {
                        console.error(`Error in ${player} plays:`, error);
                    }

                    this.scrollToBottom();
                },
                whoGoesFirst(){
                    const choices = ['A', 'B', 'C'];
                    const index = Math.floor(Math.random() * choices.length);
                    
                    let rnd = choices[index];
                    console.log(rnd, "'s turn...");
                                        
                    if (rnd === 'C') {
                        this.isInputActive = true;

                        this.currentAvatar = this.userAvatar;

                    } else if (rnd === 'A') {
                        console.log(rnd);
                        this.currentAvatar = this.aiAvatars[0]; 
                        this.playAI(rnd);
                    } else if (rnd === 'B'){
                        console.log(rnd);
                        this.currentAvatar = this.aiAvatars[1]; 
                        this.playAI(rnd);
                    }
                },
                route_to_review_A(){
                    this.$router.push({
                        name: 'review-a',
                        params: {
                            messages: JSON.stringify(this.messages),
                            userscore: this.userscore,
                            lostwho: this.lostwho,
                            evaluationA: JSON.stringify(this.evaluationA),
                            evaluationB: JSON.stringify(this.evaluationB),
                            userAvatar: this.userAvatar,
                        }
                    });
                },

                finishGame() { // force to end game
                    this.lostwho = 'C'; // Set lostwho to 'C' as the user is choosing to end the game
                    this.route_to_review_A();
                },


                async determineTurn() {
                    try {
                        const response = await fetch(`${backendUrl_for_game_A}/moderator_determines_turn`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ thread_A_id: this.thread_A_id, thread_B_id: this.thread_B_id })
                        });
                        const data = await response.json();

                        if (data.player === 'A' || data.player === 'B') {
                            this.isInputActive = false;
                            if(data.player === 'A'){
                                this.currentAvatar = this.aiAvatars[0]; 
                                console.log('turn: A');
                            } else {
                                this.currentAvatar = this.aiAvatars[1]; 
                                console.log('turn: B');
                            }

                            await this.playAI(data.player);
                        } else {
                            this.isInputActive = true; // Enable user input
                            this.currentAvatar = this.userAvatar;

                        }
                    } catch (error) {
                        console.error('Error determining turn:', error);
                    }
                },
                
                async sendMessage() {
                    if (!this.newMessage) return;

                    // Add the new message to the conversation history
                    this.messages.push({
                        text: "Player C: " + this.newMessage, 
                        sender: 'user'
                    });
                    
                    this.scrollToBottom();
                    this.isInputActive = false;

                    const maxRetries = 3; // Maximum number of retries
                    const retryDelay = 2000; // Delay between retries in milliseconds

                    for (let attempt = 1; attempt <= maxRetries; attempt++) {

                        try {
                            const response = await fetch(`${backendUrl_for_game_A}/user_C_says`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    newMessage: this.newMessage,
                                    thread_A_id: this.thread_A_id,
                                    thread_B_id: this.thread_B_id
                                })
                            });

                            if (!response.ok) {
                                throw new Error('Server responded with status ' + response.status);
                            }
                            
                            const data = await response.json();
                            console.log(data);

                            this.gameEnded = data.gameEnded;
                            this.lostwho = data.lostwho;
                            this.evaluationA = {
                                whichPlayer: data.whichPlayerByA,
                                confidenceLevel: data.confidenceLevelByA,
                                rationale: data.rationaleByA
                            };
                            this.evaluationB = {
                                whichPlayer: data.whichPlayerByB,
                                confidenceLevel: data.confidenceLevelByB,
                                rationale: data.rationaleByB
                            };
                            this.userscore += 1; 
                            this.calculate_risklevel();
                            
                            if (this.gameEnded) {
                                console.log(data);
                                try {
                                    const response = await fetch(`${backendUrl_for_game_A}/display_all_messages`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({
                                            thread_A_id: this.thread_A_id,
                                        })
                                    });

                                } catch (error) {
                                    console.error('Error retrieving all messages:', error);
                                }

                                this.route_to_review_A();
                                
                            } else {
                                this.newMessage = '';
                                await this.determineTurn(); // Determine next turn
                            }

                            return; 

                        } catch (error) {
                            console.error('Error sending message:', error);
                            console.error('Attempt ' + attempt + ' failed: ' + error.message);
                            if (attempt < maxRetries) {
                                console.log(`Retrying in ${retryDelay / 1000} seconds...`);
                                await new Promise(resolve => setTimeout(resolve, retryDelay));
                            } else {
                                console.error('All attempts failed.');
                            }
                        }
                    }
                }
            },
            template: `
                <div class="game-chat-ui-a" :style="{ backgroundImage: 'url(' + currentAvatar + ')' }">
                   
                    <div class="player-scores-and-evaluation" 
                        :class="{ 'low-risk': risklevel === 0 }" 
                        @click="evaluationA || evaluationB ? showOverlay = true : null">
                        <div>Your Score: You survived {{ userscore }} conversations </div>
                        <div>Risk Level: {{ risklevel }} 
                            <span v-if="evaluationA || evaluationB">- click to see detailed risk level</span>
                        </div>
                    </div>
              
                    <div class="evaluation-overlay" v-if="showOverlay">
                        <div class="overlay-content">
                            <button @click="showOverlay = false">Close</button>
                            <h3>Detailed AI Evaluation</h3>

                            <p><strong>A's Assessment:</strong> Suspects Player {{ evaluationA?.whichPlayer || '...' }} with {{ evaluationA?.confidenceLevel || '...' }} confidence.</p>
                            <p><strong>Rationale:</strong> {{ evaluationA?.rationale || 'No rationale provided.' }}</p>

                            <p><strong>B's Assessment:</strong> Suspects Player {{ evaluationB?.whichPlayer || '...' }} with {{ evaluationB?.confidenceLevel || '...' }} confidence.</p>
                            <p><strong>Rationale:</strong> {{ evaluationB?.rationale || 'No rationale provided.' }}</p>

                            <button @click="finishGame" class="finish-game-button">Finish Game</button>
                        </div>
                    </div>

                    <div class="chat-container">
                        <div class="conversation-history" ref="conversationHistory">
                            <div class="message" v-for="message in messages" :key="message.id">
                                <img :src="getAvatar(message.sender)" alt="Avatar" class="avatar-icon">
                                <div class="message-content">{{ message.text }}</div>
                            </div>
                        </div>
                        <div class="message-input-container" v-if="!isInputActive">
                            <p>AI is thinking...</p>
                        </div>
                        <div class="message-input-container" v-if="isInputActive">
                            <input type="text" v-model="newMessage" 
                            placeholder="You are Player C. Now it's your turn to speak as if you're an AI..." 
                            @keyup.enter="sendMessage" />
                            <button @click="sendMessage">Send</button>
                        </div>
                    </div>
                </div>
            `,       
        };

        const Review_A = {
            props: {
                userscore: Number,
                lostwho: String,
                messages: Object,
                evaluationA: Object,
                evaluationB: Object,
                userAvatar: String,
            },
            data() {
                return {
                    MyName: '',
                    isSubmitting: false, 

                };
            },
            methods: {
                async submitScore() {
                    
                    this.isSubmitting = true;

                    try {
                        
                        const submitData = {
                            name: this.MyName,
                            userscore: this.userscore,
                            lostwho: this.lostwho,
                            messages: this.parsedMessages,
                            evaluationA: this.parsedEvaluationA,
                            evaluationB: this.parsedEvaluationB,
                            leaderboard_A_or_B: 'woshiai_leaderboard_a'
                        };

                        const response = await fetch(`${backendUrl_for_submit_score}/submit_score`, { 
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(submitData)
                        });

                        if (response.ok) {
                            this.$router.push('/leaderboard-a');
                        } else {
                            // Handle errors...
                        }
                    } catch (error) {
                        console.error("Error submitting score: ", error);
                    }
                    this.isSubmitting = false; 


                },
            },
            computed: {
                parsedEvaluationA() {
                    try {
                        return JSON.parse(this.evaluationA);
                    } catch (e) {
                        console.error("Error parsing evaluationA:", e);
                        return {}; 
                    }
                },
                parsedEvaluationB() {
                    try {
                        return JSON.parse(this.evaluationB);
                    } catch (e) {
                        console.error("Error parsing evaluationB:", e);
                        return {}; 
                    }
                },
                parsedMessages() {
                    try {
                        return JSON.parse(this.messages); 
                    } catch (e) {
                        console.error("Error parsing messages:", e);
                        return {}; 
                    }
                }
            },
            mounted() {
                console.log(this.messages);
                if (this.lostwho === 'A' || this.lostwho === 'B'){
                    this.userscore += 1000; 
                };
                
            },
            template: `
                <div class="review-container" :style="{ backgroundImage: 'url(' + userAvatar + ')' }">
                    <div v-if="lostwho === 'C'">

                        <div class="user-details">
                            <h2>Your Game Review</h2>
                            <p>Your Score: {{ userscore }}</p>
                        </div>
                    </div>
                    <div v-else-if="lostwho === 'A' || lostwho === 'B'">
                        <div class="winning-message">
                            <h2>Congratulations, you won!</h2>
                            <p>You deceived one of the AI players into believing that you are an AI.</p>
                            <p>Your Score: {{ userscore }} with an additional winning bonus of +1000. </p>
                        </div>
                    </div>
    
                    <div class="score-submission">
                        <input class="submit-name-input" v-model="MyName" placeholder="Enter your name" maxlength="30">
                        <button @click="submitScore" :disabled="isSubmitting">
                            <span v-if="!isSubmitting">Submit Score</span>
                            <span v-if="isSubmitting">Submitting...</span> <!-- Add a spinner icon here if desired -->
                        </button>
                    </div>

                    <h2>AI Evaluation</h2>

                    <div class="ai-evaluation">
                        <div>
                            <strong>AI A thinks:</strong>
                            <p>Suspicious Player: {{ parsedEvaluationA.whichPlayer }}</p>
                            <p>Confidence Level: {{ parsedEvaluationA.confidenceLevel }}</p>
                            <p>Rationale: {{ parsedEvaluationA.rationale }}</p>
                        </div>
                        <div>
                            <strong>AI B thinks:</strong>
                            <p>Suspicious Player: {{ parsedEvaluationB.whichPlayer }}</p>
                            <p>Confidence Level: {{ parsedEvaluationB.confidenceLevel }}</p>
                            <p>Rationale: {{ parsedEvaluationB.rationale }}</p>
                        </div>
                    </div>
                    <div class="review-all-conv">
                        <p>Conversation History :</p>
                        <ul>
                            <li v-for="(m, index) in parsedMessages" :key="index">{{ m.text }}</li>
                        </ul>
                    </div>
                </div>
            `,
        };

        const Leaderboard_A = {
            data() {
                return {
                    leaderboard: [],
                    selectedUserDetails: null,
                    showDetailsModal: false,
                };
            },
            methods: {
                fetchLeaderboard() {
                    const q = query(collection(db, "woshiai_leaderboard_a"), 
                                    orderBy("userscore", "desc"), 
                                    limit(10)); // limit to top 10 users

                    getDocs(q).then(querySnapshot => {
                        this.leaderboard = querySnapshot.docs.map(doc => ({
                            id: doc.id,
                            ...doc.data()
                        }));
                    }).catch(error => {
                        console.error("Error fetching leaderboard data: ", error);
                    });
                    
                },
                showDetails(entry) {
                    this.selectedUserDetails = entry;
                    this.showDetailsModal = true;
                },
                closeDetails() {
                    this.showDetailsModal = false;
                },
                playAgain() {
                    this.$router.push('/game-intro');
                },
            },
            mounted() {
                this.fetchLeaderboard();
            },
            template: `
                <div class="leaderboard-container">
                    <h2>Leaderboard</h2>
                        <ul class="leaderboard-list">
                            <li v-for="entry in leaderboard" :key="entry.id" @click="showDetails(entry)">
                            <strong>{{ entry.name }}</strong>: Score: {{ entry.userscore }}
                            </li>
                        </ul>
                        <button @click="playAgain" class="play-again-button">Play Again</button>

                    <div v-if="showDetailsModal" class="evaluation-overlay">
                        <div class="overlay-content">
                            <button @click="closeDetails">Close</button>
                            <h3>Detailed User Information</h3>

                            <!-- Display selected user details and evaluations -->
                            <p><strong>User's Name:</strong> {{ selectedUserDetails.name }}</p>
                            <p><strong>User's Score:</strong> {{ selectedUserDetails.score }}</p>
                            <div class="review-all-conv">

                                <p><strong>Conversation History:</strong></p>
                                <ul v-if="selectedUserDetails.messages.length">
                                    <li v-for="(message, index) in selectedUserDetails.messages" :key="index">{{ message.text }}</li>
                                </ul>
                                <p v-else>No conversation history available.</p>
                            </div>

                            <h3>AI Evaluation</h3>
                            <div>
                                <strong>Player A's Assessment:</strong>
                                <p>Suspicious Player: {{ selectedUserDetails.evaluationA.whichPlayer }}</p>
                                <p>Confidence Level: {{ selectedUserDetails.evaluationA.confidenceLevel }}%</p>
                                <p>Rationale: {{ selectedUserDetails.evaluationA.rationale }}</p>
                            </div>
                            <div>
                                <strong>Player B's Assessment:</strong>
                                <p>Suspicious Player: {{ selectedUserDetails.evaluationB.whichPlayer }}</p>
                                <p>Confidence Level: {{ selectedUserDetails.evaluationB.confidenceLevel }}%</p>
                                <p>Rationale: {{ selectedUserDetails.evaluationB.rationale }}</p>
                            </div>


                        </div>
                    </div>

                </div>
            `,
        };


        const GameChatUI_B = {
            data() {
                return {
                    messages: [],
                    newMessage: '',
                    userscore: 0,
                    risklevel: 0,
                    thread_A_id: null,
                    thread_B_id: null,
                    isInputActive: false,
                    evaluationA: null,
                    gameEnded: false,

                    lostwho: '',

                    showOverlay: false,
                };
            },
            props: {
                userAvatar: String,
                aiAvatars: Array
            },
            async mounted() {
                await this.initializeGame();
                await this.whoGoesFirst();

            },
            methods: {
                getAvatar(sender) {
                    switch (sender) {
                        case 'user': return this.userAvatar;
                        case 'A': return this.aiAvatars[0];
                        case 'B': return this.aiAvatars[1];
                        default: return ''; 
                    }
                },
                scrollToBottom() {
                    this.$nextTick(() => {
                        const chatContainer = this.$refs.conversationHistory;
                        if (chatContainer) {
                            chatContainer.scrollTop = chatContainer.scrollHeight;
                        }
                    });
                },
                calculate_risklevel() {

                    if (this.evaluationA.whichPlayer === 'B') { // && this.evaluationB.whichPlayer === 'C') {
                        const confidenceA = parseFloat(this.evaluationA.confidenceLevel);

                        console.log('risk level: ', confidenceA);//, confidenceB);

                        if ( !isNaN(confidenceA) ) {
                            const risk = (confidenceA) * 100;
                            
                            this.risklevel = risk;
                        }
                    }
                    else {
                        this.risklevel = 0;
                    } 
                },
                async initializeGame() {
                    try {
                        const response = await fetch(`${backendUrl_for_game_B}/initialize_game`);

                        const data = await response.json();
                        this.thread_A_id = data.thread_A_id;
                        this.thread_B_id = data.thread_B_id;
                    } catch (error) {
                        console.error('Error initializing game:', error);
                    }
                },
                async playAI(player) {
                    try {
                        const response = await fetch(`${backendUrl_for_game_B}/${player}_plays`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ thread_A_id: this.thread_A_id, thread_B_id: this.thread_B_id })
                        });
                        const data = await response.json();
                        this.messages.push({ text: data.message, sender: player });
                        this.userscore += 1; 
                        
                        await this.determineTurn();
                    } catch (error) {
                        console.error(`Error in ${player} plays:`, error);
                    }

                    this.scrollToBottom();
                },
                whoGoesFirst(){
                    const choices = ['A', 'B', 'C'];
                    const index = Math.floor(Math.random() * choices.length);
                    
                    let rnd = choices[index];
                    console.log(rnd, "'s turn...");
                                        
                    if (rnd === 'C') {
                        this.isInputActive = true;

                        this.currentAvatar = this.userAvatar;

                    } else if (rnd === 'A') {
                        console.log(rnd);
                        this.currentAvatar = this.aiAvatars[0]; 
                        this.playAI(rnd);
                    } else if (rnd === 'B'){
                        console.log(rnd);
                        this.currentAvatar = this.aiAvatars[1]; 
                        this.playAI(rnd);
                    }
                },
                route_to_review_B(){
                    this.$router.push({
                        name: 'review-b',
                        params: {
                            messages: JSON.stringify(this.messages),
                            userscore: this.userscore,
                            lostwho: this.lostwho,
                            evaluationA: JSON.stringify(this.evaluationA),
                            userAvatar: this.userAvatar,
                        }
                    });
                },

                finishGame() { 
                    this.lostwho = 'C'; // Set lostwho to 'C' as the user is choosing to end the game
                    this.route_to_review_B();
                },

                async determineTurn() {
                    try {
                        const response = await fetch(`${backendUrl_for_game_B}/moderator_determines_turn`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ thread_A_id: this.thread_A_id, thread_B_id: this.thread_B_id })
                        });
                        const data = await response.json();
                        
                        if (data.player === 'A' || data.player === 'B') {
                            this.isInputActive = false; 
                            if(data.player === 'A'){
                                this.currentAvatar = this.aiAvatars[0]; 
                                console.log('turn: A');
                            } else {
                                this.currentAvatar = this.aiAvatars[1]; 
                                console.log('turn: B');
                            }

                            await this.playAI(data.player);
                        } else {
                            this.isInputActive = true; 
                            this.currentAvatar = this.userAvatar;

                        }
                    } catch (error) {
                        console.error('Error determining turn:', error);
                    }
                },
                
                async sendMessage() {
                    if (!this.newMessage) return;

                    this.messages.push({
                        text: "Player C: " + this.newMessage, 
                        sender: 'user'
                    });
                    
                    this.scrollToBottom();
                    this.isInputActive = false;

                    const maxRetries = 3; 
                    const retryDelay = 2000;

                    for (let attempt = 1; attempt <= maxRetries; attempt++) {

                        try {
                            const response = await fetch(`${backendUrl_for_game_B}/user_C_says`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    newMessage: this.newMessage,
                                    thread_A_id: this.thread_A_id,
                                    thread_B_id: this.thread_B_id
                                })
                            });

                            if (!response.ok) {
                                throw new Error('Server responded with status ' + response.status);
                            }
                            
                            const data = await response.json();
                            console.log(data);

                            this.gameEnded = data.gameEnded;
                            this.evaluationA = {
                                whichPlayer: data.whichPlayerByA,
                                confidenceLevel: data.confidenceLevelByA,
                                rationale: data.rationaleByA
                            };
                            
                            this.userscore += 1; 
                            this.calculate_risklevel();
                            
                            if (this.gameEnded) {
                                console.log(data);
                                try {
                                    const response = await fetch(`${backendUrl_for_game_B}/display_all_messages`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({
                                            thread_A_id: this.thread_A_id,
                                        })
                                    });

                                } catch (error) {
                                    console.error('Error retrieving all messages:', error);
                                }

                                this.route_to_review_B();
                                
                            } else {
                                this.newMessage = '';
                                await this.determineTurn(); 
                            }

                            return; 

                        } catch (error) {
                            console.error('Error sending message:', error);
                            console.error('Attempt ' + attempt + ' failed: ' + error.message);
                            if (attempt < maxRetries) {
                                console.log(`Retrying in ${retryDelay / 1000} seconds...`);
                                await new Promise(resolve => setTimeout(resolve, retryDelay));
                            } else {
                                console.error('All attempts failed.');
                                
                            }
                        }
                    }
                }
            },
            template: `
                <div class="game-chat-ui-b" :style="{ backgroundImage: 'url(' + currentAvatar + ')' }">

                    <div class="player-scores-and-evaluation" 
                        :class="{ 'low-risk': risklevel === 0 }" 
                        @click="evaluationA ? showOverlay = true : null">
                        <div>Your Score: You survived {{ userscore }} conversations </div>
                        <div>Risk Level: {{ risklevel }} 
                            <span v-if="evaluationA ">- click to see detailed risk level</span>
                        </div>
                    </div>
              
                    <div class="evaluation-overlay" v-if="showOverlay">
                        <div class="overlay-content">
                            <button @click="showOverlay = false">Close</button>
                            <h3>Detailed AI Evaluation</h3>

                            <p><strong>A's Assessment:</strong> The Judge (Player A) thinks Player {{ evaluationA?.whichPlayer || '...' }} is human, with {{ evaluationA?.confidenceLevel || '...' }} confidence.</p>
                            <p><strong>Rationale:</strong> {{ evaluationA?.rationale || 'No rationale provided.' }}</p>

                            <button @click="finishGame" class="finish-game-button">Finish Game</button>

                        </div>
                    </div>
                    <div class="chat-container">
                        <div class="conversation-history" ref="conversationHistory">
                            <div class="message" v-for="message in messages" :key="message.id">
                                <img :src="getAvatar(message.sender)" alt="Avatar" class="avatar-icon">
                                <div class="message-content">{{ message.text }}</div>
                            </div>
                        </div>
                        <div class="message-input-container" v-if="!isInputActive">
                            <p>AI is thinking...</p>
                        </div>
                        <div class="message-input-container" v-if="isInputActive">
                            <input type="text" v-model="newMessage" 
                            placeholder="You are Player C. Now it's your turn to demonstrate that you're a human..." 
                            @keyup.enter="sendMessage" />
                            <button @click="sendMessage">Send</button>
                        </div>
                    </div>
                </div>
            `,       
        };

        const Review_B = {
            props: {
                userscore: Number,
                lostwho: String,
                messages: Object,
                evaluationA: Object,
                userAvatar: String,
            },
            data() {
                return {
                    MyName: '',
                    isSubmitting: false,

                };
            },
            methods: {
                async submitScore() {
                    
                    this.isSubmitting = true;

                    try {
                        
                        const submitData = {
                            name: this.MyName,
                            userscore: this.userscore,
                            lostwho: this.lostwho,
                            messages: this.parsedMessages,
                            evaluationA: this.parsedEvaluationA,
                            leaderboard_A_or_B: 'woshiai_leaderboard_b'
                        };

                        const response = await fetch(`${backendUrl_for_submit_score}/submit_score`, { 
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(submitData)
                        });

                        if (response.ok) {
                            
                            this.$router.push('/leaderboard-b');
                        } else {
                            // Handle errors...
                        }
                    } catch (error) {
                        console.error("Error submitting score: ", error);
                    }
                    this.isSubmitting = false;

                },
            },
            computed: {
                parsedEvaluationA() {
                    try {
                        return JSON.parse(this.evaluationA);
                    } catch (e) {
                        console.error("Error parsing evaluationA:", e);
                        return {}; // Return an empty object in case of error
                    }
                },
                parsedMessages() {
                    try {
                        return JSON.parse(this.messages); 
                    } catch (e) {
                        console.error("Error parsing messages:", e);
                        return {}; 
                    }
                }
            },
            mounted() {
                
                console.log(this.evaluationA);
                if (this.lostwho === 'B'){// || this.lostwho === 'B'){
                    this.userscore += 1000;
                };
                
            },
            template: `
                <div class="review-container" :style="{ backgroundImage: 'url(' + userAvatar + ')' }">
                    <div v-if="lostwho === 'C'">

                        <div class="user-details">
                            <h2>Your Game Review</h2>
                            <p>Your Score: {{ userscore }}</p>
                        </div>
                    </div>
                    <div v-else-if="lostwho === 'B'">
                        <div class="winning-message">
                            <h2>Congratulations, you won!</h2>
                            <p>You successfully convinced the AI that you are human.</p>
                            <p>Your Score: {{ userscore }} with an additional winning bonus of +1000. </p>
                        </div>
                    </div>
                    <div class="ai-evaluation">
                        <h2>AI Evaluation</h2>
                        <div>
                            <strong>AI A thinks:</strong>
                            <p>Human Player: {{ parsedEvaluationA.whichPlayer }}</p>
                            <p>Confidence Level: {{ parsedEvaluationA.confidenceLevel }}</p>
                            <p>Rationale: {{ parsedEvaluationA.rationale }}</p>
                        </div>
                    </div>
                    <div class="review-all-conv">
                        <p>Conversation History :</p>
                        <ul>
                            <li v-for="(m, index) in parsedMessages" :key="index">{{ m.text }}</li>
                        </ul>
                    </div>

                    <div class="score-submission">
                        <input class="submit-name-input" v-model="MyName" placeholder="Enter your name" maxlength="30">
                        <button @click="submitScore" :disabled="isSubmitting">
                            <span v-if="!isSubmitting">Submit Score</span>
                            <span v-if="isSubmitting">Submitting...</span> 
                        </button>
                    </div>
                </div>
            `,
        };

        const Leaderboard_B = {
            data() {
                return {
                    leaderboard: [],
                    selectedUserDetails: null,
                    showDetailsModal: false,
                };
            },
            methods: {
                fetchLeaderboard() {
                    const q = query(collection(db, "woshiai_leaderboard_b"), 
                                    orderBy("userscore", "desc"), 
                                    limit(10)); // limit to top 10 users

                    getDocs(q).then(querySnapshot => {
                        this.leaderboard = querySnapshot.docs.map(doc => ({
                            id: doc.id,
                            ...doc.data()
                        }));
                    }).catch(error => {
                        console.error("Error fetching leaderboard data: ", error);
                    });
                    
                },
                showDetails(entry) {
                    this.selectedUserDetails = entry;
                    this.showDetailsModal = true;
                },
                closeDetails() {
                    this.showDetailsModal = false;
                },
                playAgain() {
                    this.$router.push('/game-intro');
                },
            },
            mounted() {
                this.fetchLeaderboard();
            },
            template: `
                <div class="leaderboard-container">
                    <h2>Leaderboard</h2>
                        <ul class="leaderboard-list">
                            <li v-for="entry in leaderboard" :key="entry.id" @click="showDetails(entry)">
                            <strong>{{ entry.name }}</strong>: Score: {{ entry.userscore }}
                            </li>
                        </ul>
                        <button @click="playAgain" class="play-again-button">Play Again</button>

                    <div v-if="showDetailsModal" class="evaluation-overlay">
                        <div class="overlay-content">
                            <button @click="closeDetails">Close</button>
                            <h3>Detailed User Information</h3>

                            <p><strong>User's Name:</strong> {{ selectedUserDetails.name }}</p>
                            <p><strong>User's Score:</strong> {{ selectedUserDetails.score }}</p>
                            <div class="review-all-conv">

                                <p><strong>Conversation History:</strong></p>
                                <ul v-if="selectedUserDetails.messages.length">
                                    <li v-for="(message, index) in selectedUserDetails.messages" :key="index">{{ message.text }}</li>
                                </ul>
                                <p v-else>No conversation history available.</p>
                            </div>

                            <h3>AI Evaluation</h3>
                            <div>
                                <strong>Player A's Assessment:</strong>
                                <p>Human Player: {{ selectedUserDetails.evaluationA.whichPlayer }}</p>
                                <p>Confidence Level: {{ selectedUserDetails.evaluationA.confidenceLevel }}%</p>
                                <p>Rationale: {{ selectedUserDetails.evaluationA.rationale }}</p>
                            </div>
                        </div>
                    </div>
                </div>
            `,
        };

        
        const routes = [

            { path: '/', component: Welcome },
            { path: '/game-intro', component: GameIntroPage },
            { path: '/avatar-selection', component: AvatarSelection },
            { path: '/game-chat-ui-a', component: GameChatUI_A, name: 'game-chat-ui-a', props: true },
            { path: '/game-chat-ui-b', component: GameChatUI_B, name: 'game-chat-ui-b', props: true },
            { path: '/review-a', component: Review_A, name: 'review-a', props: true },
            { path: '/review-b', component: Review_B, name: 'review-b', props: true },
            { path: '/leaderboard-a', component: Leaderboard_A, name: 'leaderboard-a', props: true },
            { path: '/leaderboard-b', component: Leaderboard_B, name: 'leaderboard-b', props: true },

        ];

        const router = VueRouter.createRouter({
            history: VueRouter.createWebHashHistory(),
            routes,
        });
        router.beforeEach((to, from, next) => {
            if (to.path === '/' || to.path === '/game-intro') {
                    if (images.length === 0) {
                        preloadImages();
                    }
                } else {
                    // If navigating away from '/' or '/game-intro', clear the slideshow interval
                    clearInterval(slideshowInterval);
                }
            next();
        });

        const app = Vue.createApp({
            data() {
                return {
                    selectedGame: null, 
                    currentAvatar: '',
                };
            },
        });

        const images = [];
        const totalImages = 12;
        const imagePathPrefix = './images/'; 

        let slideshowInterval = null;

        function preloadImages() {
            for (let i = 1; i <= totalImages; i++) {
                const img = new Image();
                img.src = `${imagePathPrefix}Character_${i}.png`;
                img.onload = function() {
                    images.push(img); // Only add to array once loaded
                    if (images.length === totalImages) {
                        app.config.globalProperties.$images = images; 
                        startSlideshow();
                    }
                };
            }
        }

        function startSlideshow() {
            let currentImageIndex = 0;
            function changeImage() {
                const imageContainer = document.getElementById('imageContainer');
                if (imageContainer) {
                    imageContainer.style.opacity = 0; 
                    setTimeout(() => {
                        imageContainer.innerHTML = `<img src="${images[currentImageIndex].src}" alt="Player Image">`;
                        imageContainer.style.opacity = 1;
                        currentImageIndex = (currentImageIndex + 1) % images.length;
                    }, 0); 
                }
            }
            
            clearInterval(slideshowInterval);
            slideshowInterval = setInterval(changeImage, 3693);
            
        }

        app.use(router); 

        app.mount('#app');
    </script>
    
</body>
</html>
